<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冬日の草原</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://amito.me/"/>
  <updated>2020-04-13T03:49:33.098Z</updated>
  <id>https://amito.me/</id>
  
  <author>
    <name>Yujiang Bi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Map and Mount Ceph RBD on Remote Servers</title>
    <link href="https://amito.me/2020/Map-and-Mount-Ceph-RBD-on-Remote-Servers/"/>
    <id>https://amito.me/2020/Map-and-Mount-Ceph-RBD-on-Remote-Servers/</id>
    <published>2020-04-03T07:09:59.000Z</published>
    <updated>2020-04-13T03:49:33.098Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Ceph 存储一个重要的使用场景就是其块设备，本文将会介绍一下如何挂载 Ceph RBD 到远程服务器上。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="Prerequisites">Prerequisites</h2><p>ceph repo:</p><pre class=" language-language-bash"><code class="language-language-bash">[ceph]name=Ceph packages for $basearchbaseurl=https://download.ceph.com/rpm-mimic/el7/$basearchenabled=1priority=2gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc[ceph-noarch]name=Ceph noarch packagesbaseurl=https://download.ceph.com/rpm-mimic/el7/noarchenabled=1priority=2gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc[ceph-source]name=Ceph source packagesbaseurl=https://download.ceph.com/rpm-mimic/el7/SRPMSenabled=0priority=2gpgcheck=1gpgkey=https://download.ceph.com/keys/release.asc</code></pre><p>Install rbd clients:</p><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum install -y ceph-common python-rbd</code></pre><h2 id="Create-RBD">Create RBD</h2><pre class=" language-language-bash"><code class="language-language-bash">$ rbd create --pool volulmes --size 50G lintao_test</code></pre><h2 id="Mount">Mount</h2><h3 id="Config">Config</h3><p><code>/etc/ceph/ceph.conf</code>:</p><pre class=" language-language-bash"><code class="language-language-bash">[global]fsid = 1da65d0e-4284-41e0-868e-8c25b89648fcmon_initial_members = ceph01, ceph02, ceph03mon_host = 192.168.15.38,192.168.15.39,192.168.15.40auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephx[mon]mgr initial modules = dashboard[client.cinder]keyring = /etc/ceph/ceph.client.cinder.keyring</code></pre><p><code>/etc/ceph/ceph.client.cinder.keyring</code>:</p><pre class=" language-language-bash"><code class="language-language-bash">[client.cinder]key = AQBooSldwwbkAhAAtxRH0lHGfnUautW2rF6pkQ==</code></pre><h3 id="rbd-map">rbd map</h3><ol><li>map rbd</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo rbd map volumes/lintao_test --id cinder/dev/rbd0</code></pre><ol start="2"><li>if unmap rbd</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo rbd unmap volumes/lintao_test --id cinder</code></pre><h3 id="format-mount">format &amp; mount</h3><pre class=" language-language-bash"><code class="language-language-bash">$ sudo fdisk /dev/rbd/volumes/lintao_test...$ sudo mkfs.ext4 /dev/rbd/volumes/lintao_test-part1...$ sudo mkdir /data $ sudo mount /dev/rbd/volumes/lintao_test-part1 /data</code></pre><h3 id="automount">automount</h3><ol><li><code>/etc/ceph/rbdmap</code></li></ol><pre class=" language-language-bash"><code class="language-language-bash">volumes/lintao_test id=cinder,keyring=/etc/ceph/ceph.client.keyring</code></pre><ol start="2"><li>enable rbdmap service</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo systemctl enable --now rbdmap</code></pre><ol start="3"><li><code>/etc/fstab</code></li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo blkid /dev/rbd/volumes/lintao_test-part1### /etc/fstabUUID=0a9d74d8-8f37-4a80-ac70-28c292e79784    /data    ext4 defaults 0 0</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ceph 存储一个重要的使用场景就是其块设备，本文将会介绍一下如何挂载 Ceph RBD 到远程服务器上。&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="https://amito.me/categories/Ceph/"/>
    
    
      <category term="Ceph" scheme="https://amito.me/tags/Ceph/"/>
    
      <category term="RBD" scheme="https://amito.me/tags/RBD/"/>
    
  </entry>
  
  <entry>
    <title>在 CentOS 8 下安装并配置 Docker</title>
    <link href="https://amito.me/2020/Install-and-Setup-Docker-under-CentOS-8/"/>
    <id>https://amito.me/2020/Install-and-Setup-Docker-under-CentOS-8/</id>
    <published>2020-03-05T16:10:50.000Z</published>
    <updated>2020-04-13T03:20:25.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 红帽已经在 CentOS 8 中用 Podman 替代了 Docker， 它是与 Docker 类似的容器技术，使用命令都十分相似， 但对于熟悉 Docker 及配置的管理人员，他们可能会倾向于使用 Docker。 本文会简单介绍如何在 CentOS 8 下安装、配置 Docker。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="安装 -Docker"> 安装 Docker</h2><h3 id="准备工作"> 准备工作 </h3><ol><li> 卸载旧版本的 Docker.</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo dnf remove docker-common docker  container-selinux docker-selinux docker-engine</code></pre><ol start="2"><li> 添加 Docker 安装源 </li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo curl  https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo</code></pre><ol start="3"><li> 安装最新版的 <code>Containerd</code>. 你可能需要主动查看最新版本，目前 (06/03/2020) 是 <code>1.2.6-3.3</code>.</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo dnf install -y https://download.docker.com/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm</code></pre><ol start="4"><li> 安装 Docker CE</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo dnf install -y docker-ce</code></pre><ol start="5"><li> 启用 Docker 服务 </li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo systemctl enable --now docker</code></pre><ol start="6"><li> 为非 Root 用户添加运行 Docker 的权限 </li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo groupadd docker$ sudo useradd -m -d /home/test -U -r test$ sudo usermoad -aG docker test</code></pre><ol start="7"><li> 验证 Docker 是否正确安装 </li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ docker run busybox ping -c 5 google.com</code></pre><p> 不出意外， docker  ping  是不通的。 我们安装的 Docker 是有问题的， 防火墙并没有正确配置。</p><h2 id="配置系统防火墙"> 配置系统防火墙 </h2><h3 id="0- 开启 -IP- 转发">0. 开启 IP 转发 </h3><pre class=" language-language-bash"><code class="language-language-bash">$ echo "net.ipv4.ip_forward = 1" | sudo tee /etc/sysctl.conf$ sudo sysctl -p</code></pre><h3 id="1- 关闭防火墙">1. 关闭防火墙 </h3><p>One easily way that makes docker access the network is stop the firewall. CentOS 8 using firewalld with <code>nftables</code> to protect the system.</p><pre class=" language-language-bash"><code class="language-language-bash">$ sudo systemctl disable --now firewalld$ sudo systemctl mask --now firewalld</code></pre><p>But this will expose our server to security attacks. So, we need configure the firewalld to granting docker the network access.</p><h3 id="2- 配置防火墙">2. 配置防火墙 </h3><ol><li> 检查活动的 <code>zone</code> 和 <code>docker0</code> 所在的 <code>zone</code></li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo firewall-cmd --get-active-zones$ sudo firewall-cmd --get-zone-of-interface=docker0</code></pre><p> 我们发现 Docker 的 <code>docker0</code> 没有在任何 <code>zone</code> 中, 我们需要将其加到某一个 <code>zone</code> 如 <code>public</code> 中 </p><ol><li> 添加 <code>docker0</code> 到 <code>public</code> zone.</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ firewall-cmd --permanent --zone=public --change-interface=docker0#or$ firewall-cmd --permanent --zone=public --add-interface=docker0#or$ nmcli connection modify docker0 connection.zone public</code></pre><ol start="3"><li> 为 <code>docker0</code> 配置 iptables 规则.</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ firewall-cmd --permanent --direct --add-rule ipv4 filter INPUT 4 -i docker0 -j ACCEPT$ firewall-cmd --permanent --direct --add-rule ipv6 filter INPUT 6 -i docker0 -j ACCEPT$ firewall-cmd --zone=public --add-masquerade --permanent</code></pre><ol start="4"><li> 打开所需要的端口.</li></ol><pre class=" language-language-bash"><code class="language-language-bash">## dns$ firewall-cmd --zone=public --add-port=53/tcp## http$ firewall-cmd --zone=public --add-port=80/tcp## https$ firewall-cmd --zone=public --add-port=443/tcp</code></pre><ol start="5"><li> 重新载入防火墙规则，重启 Docker 服务.</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo firewall-cmd --reload$ sudo systemctl restart docker</code></pre><ol start="6"><li> 验证 Docker 是否能连接网络 </li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ docker run busybox ping -c 5 google.comPING google.com (172.217.11.46): 56 data bytes64 bytes from 172.217.11.46: seq=0 ttl=55 time=10.850 ms64 bytes from 172.217.11.46: seq=1 ttl=55 time=1.786 ms64 bytes from 172.217.11.46: seq=2 ttl=55 time=1.759 ms64 bytes from 172.217.11.46: seq=3 ttl=55 time=1.978 ms64 bytes from 172.217.11.46: seq=4 ttl=55 time=1.797 ms--- google.com ping statistics ---5 packets transmitted, 5 packets received, 0% packet lossround-trip min/avg/max = 1.759/3.634/10.850 ms</code></pre><p> 可以看到，现在 Docker  已经能够访问网络了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红帽已经在 CentOS 8 中用 Podman 替代了 Docker， 它是与 Docker 类似的容器技术，使用命令都十分相似， 但对于熟悉 Docker 及配置的管理人员，他们可能会倾向于使用 Docker。 本文会简单介绍如何在 CentOS 8 下安装、配置 Docker。&lt;/p&gt;
    
    </summary>
    
      <category term="Docker" scheme="https://amito.me/categories/Docker/"/>
    
    
      <category term="CentOS" scheme="https://amito.me/tags/CentOS/"/>
    
      <category term="Docker" scheme="https://amito.me/tags/Docker/"/>
    
      <category term="Firewalld" scheme="https://amito.me/tags/Firewalld/"/>
    
  </entry>
  
  <entry>
    <title>connecting redis cluster using python</title>
    <link href="https://amito.me/2020/connecting-redis-cluster-using-python/"/>
    <id>https://amito.me/2020/connecting-redis-cluster-using-python/</id>
    <published>2020-02-15T11:33:35.000Z</published>
    <updated>2020-04-13T03:20:25.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Connecting redis cluster using python.</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Connecting redis cluster using python.&lt;/p&gt;
    
    </summary>
    
      <category term="SQL" scheme="https://amito.me/categories/SQL/"/>
    
    
      <category term="Redis" scheme="https://amito.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>给你的网站加上 Google Adsense</title>
    <link href="https://amito.me/2020/adding-google-adsense-to-your-site/"/>
    <id>https://amito.me/2020/adding-google-adsense-to-your-site/</id>
    <published>2020-02-15T09:11:56.000Z</published>
    <updated>2020-04-13T03:20:25.758Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 本文简单记录了给 Hexo 添加 Google Adsense 的过程，模板是简单修改过的 <a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak" target="_blank" rel="noopener">tranquilpeak</a>.</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="Intro">Intro</h2><div class="figure" style="width:;"><img class="fig-img" src="google-adsense.png" alt=""></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单记录了给 Hexo 添加 Google Adsense 的过程，模板是简单修改过的 &lt;a href=&quot;https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;tranquilpeak&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="碎碎念" scheme="https://amito.me/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
      <category term="hexo" scheme="https://amito.me/tags/hexo/"/>
    
      <category term="google" scheme="https://amito.me/tags/google/"/>
    
  </entry>
  
  <entry>
    <title>Dashboard in Ceph</title>
    <link href="https://amito.me/2019/Dashboard-in-Ceph/"/>
    <id>https://amito.me/2019/Dashboard-in-Ceph/</id>
    <published>2019-04-23T13:43:48.000Z</published>
    <updated>2020-04-13T03:20:25.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>This post will discuss the dashboard feature in ceph mgr.</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;This post will discuss the dashboard feature in ceph mgr.&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="https://amito.me/categories/Ceph/"/>
    
    
      <category term="Ceph" scheme="https://amito.me/tags/Ceph/"/>
    
      <category term="Grafana" scheme="https://amito.me/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>使用 Ansible 来部署 Ceph 集群</title>
    <link href="https://amito.me/2019/Using-Ansible-to-Deploy-Ceph/"/>
    <id>https://amito.me/2019/Using-Ansible-to-Deploy-Ceph/</id>
    <published>2019-04-22T14:03:31.000Z</published>
    <updated>2020-04-13T03:20:25.740Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Ansible is the AutoDev tool developed by RedHat and we can easily deploy Ceph using ansible.</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ansible is the AutoDev tool developed by RedHat and we can easily deploy Ceph using ansible.&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="https://amito.me/categories/Ceph/"/>
    
    
      <category term="Ceph" scheme="https://amito.me/tags/Ceph/"/>
    
      <category term="Ansible" scheme="https://amito.me/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>在 Beamer 中添加计时器和 Logo</title>
    <link href="https://amito.me/2019/Adding-Timer-and-Logo-in-Beamer/"/>
    <id>https://amito.me/2019/Adding-Timer-and-Logo-in-Beamer/</id>
    <published>2019-04-16T00:48:18.000Z</published>
    <updated>2020-04-13T03:20:25.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 在 PPT 中有一个演讲计时功能，能够帮助报告人掌握演讲时间。 其实 pdf 中也有这一功能，在 beamer 中添加计时器比较方便。 此外，在 beamer 标题中加上特定的 Logo 也是比较简单的。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="添加 -timer- 计时器"> 添加 timer 计时器 </h2><p>LaTeX 中 <strong>tdclock</strong> 包可以提供定时功能。添加一个计时器也很简单。</p><ol><li><p> 在导言区加入 <strong>tdclock</strong> 包。可以设置一次提醒，二次提醒时间，更新时间间隔等等。</p><pre class=" language-language-tex"><code class="language-language-tex">\usepackage[timeinterval=2.0, timeduration=2.0, timedeath=0,fillcolorwarningsecond=white!60!yellow,timewarningfirst=900,timewarningsecond=1080]{tdclock}</code></pre></li><li><p><strong>\initclock</strong> 初始化。在适当的位置，如 titlepage 中加入这一命令。</p><pre class=" language-language-tex"><code class="language-language-tex">\begin{frame}\titlepage\initclock\end{frame}</code></pre></li><li><p> 在要显示的地方加入 <strong>\crono</strong> 命令，比如在 footer 中。如果使用的三段式 footer 结构，可以在 footer 中显示时间，则可以这样做：</p><pre class=" language-language-tex"><code class="language-language-tex">\begin{frame}\titlepage\initclock\end{frame}\date{\today \crono}</code></pre></li></ol><p> 这样会显示日期和从 <strong>00:00:00</strong> 开始的计时器，如下图黑框所示。<br><img src="timer.png" alt="timer"></p><ol start="4"><li><strong>tdclock</strong> 与 <strong>xelatex</strong> 一起使用会有些小问题，会显示不完全， <a href="https://tex.stackexchange.com/a/407730" target="_blank" rel="noopener"> 这里 </a> 提供了一种解决方法。测试是可以的。</li></ol><h2 id="在 -frame- 中加入 -logo"> 在 frame 中加入 logo</h2><h3 id="在标题中加入 -logo"> 在标题中加入 logo</h3><p> 通过简单地修改 frametitle 就能加入 logo， 而不用 textopt 等包。</p><ol><li><p> 在 <strong>\begin{document}</strong>  之前重新定义 frametitle，这会在 frametitle 最右端显示一个 logo:</p><pre class=" language-language-tex"><code class="language-language-tex">\setbeamertemplate{frametitle}{\begin{beamercolorbox}[wd=\paperwidth]{frametitle}      \strut\hspace{0.5em}\insertframetitle\strut      \hfill      \raisebox{-2mm}{\includegraphics[width=1cm]{$logo$}}    \end{beamercolorbox}}</code></pre></li><li><p> 只为 titlepage 页面，定义新的 logo，而不是在 title 中添加 logo。</p><pre class=" language-language-tex"><code class="language-language-tex">{\setbeamertemplate{logo}{}\titlegraphic{\includegraphics[height=1.8cm]{images/logo.jpg}\hspace{1em}\includegraphics[height=1.8cm]{images/lhaaso.png}}\begin{frame}\titlepage\initclock\end{frame}}</code></pre></li><li><p> 最终结果如下图所示 </p></li></ol><p><img src="logo.png" alt="logo"></p><h3 id="在页面右下角加入 -logo。"> 在页面右下角加入 logo。</h3><p> 有时我们会想在其它地方加上 logo， 比如 页面右下角， 这时一般直接使用 <strong>\logo</strong> 命令即可。</p><pre class=" language-language-tex"><code class="language-language-tex">\logo{\includegraphics[height=1cm]{my_logo.png}</code></pre><p> 如果想要调整位置，可以使用 pgf 命令， 但坐标位置需要仔细调整。</p><pre class=" language-language-tex"><code class="language-language-tex">\logo{\pgfputat{\pgfxy(-9,9)}{\pgfbox[center,base]{\includegraphics[width=1.5cm]{$logo$}}}}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 PPT 中有一个演讲计时功能，能够帮助报告人掌握演讲时间。 其实 pdf 中也有这一功能，在 beamer 中添加计时器比较方便。 此外，在 beamer 标题中加上特定的 Logo 也是比较简单的。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://amito.me/categories/LaTeX/"/>
    
    
      <category term="LaTeX" scheme="https://amito.me/tags/LaTeX/"/>
    
      <category term="Beamer" scheme="https://amito.me/tags/Beamer/"/>
    
  </entry>
  
  <entry>
    <title>使用 Autotool 工具链编译动态链接库</title>
    <link href="https://amito.me/2019/Build-Shared-Libs-Using-Autotools/"/>
    <id>https://amito.me/2019/Build-Shared-Libs-Using-Autotools/</id>
    <published>2019-03-14T05:10:43.000Z</published>
    <updated>2020-04-13T03:20:25.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 最近需要将几个静态编译的包改成动态编译的库，幸运的是，它们都是用 autoconf 那一套工具生成 configure 文件，转换起来很方便。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="从静态编译到动态编译"> 从静态编译到动态编译 </h2><p> 基本上，对于一个目录结构如下的简单的包，</p><pre><code>- include:    - a.h    - b.h    - Makefile.am    - ...- lib:    - a.cpp    - b.cpp    - Makefile.am    - ...- configure.ac- ...</code></pre><p> 需要修改的只有两个文件 - <code>configure.ac</code> 和 <code>lib/Makefile.am</code>.</p><h2 id="Configure-ac"><a href="http://Configure.ac" target="_blank" rel="noopener">Configure.ac</a></h2><p> 一般地， <code>configure.ac</code> 文件的开头会类似如下面所示：</p><pre class=" language-language-bash"><code class="language-language-bash">dnl Process this file with autoconf to produce a configure script.AC_INIT(xxx, xxx, [xxxx])AC_CONFIG_AUX_DIR(config)AC_CONFIG_SRCDIR([lib/xxx.c])AC_CONFIG_SRCDIR([examples/xxx.c])AC_CONFIG_HEADER([include/xxx.h])AM_INIT_AUTOMAKE([subdir-objects])</code></pre><p> 需要做的是，在这后面加上 </p><pre class=" language-language-bash"><code class="language-language-bash">AC_ENABLE_SHAREDAC_DISABLE_STATICLT_INIT</code></pre><p> 这里只编译动态链接的版本，所以加上了 <code>AC_DISABLE_STATIC</code>，这也是为方便之后修改 <code>lib/Makefile.am</code> 文件。</p><h2 id="lib-Makefile-am">lib/Makefile.am</h2><p><code>lib/Makefile.am</code> 文件中一般会有如下的内容 </p><pre class=" language-language-bash"><code class="language-language-bash">lib_LIBRARIES = libxxx.alibxxx_a_CFLAGS= xxxlibxxx_a_CPPFLAGS= xxxlibxxx_a_CXXFLAGS= xxxlibxxx_a_LDFLAGS= xxxlibxxx_a_SOURCES= xxx</code></pre><p> 如果只编译动态链接的版本，只需要替换成如下的内容：</p><pre class=" language-language-bash"><code class="language-language-bash">lib_LTLIBRARIES = libxxx.lalibxxx_la_CFLAGS= xxxlibxxx_la_CPPFLAGS= xxxlibxxx_la_CXXFLAGS= xxxlibxxx_la_LDFLAGS= xxxlibxxx_la_SOURCES= xxx</code></pre><p> 如果要编译静态版本，最好用没修改过的版本进行编译，或者将上面的内容加上 <a href="http://Makefile.am" target="_blank" rel="noopener">Makefile.am</a> 中。</p><p><strong> 注 </strong>： 若有多个 libxxx.a, 则都需要进行修改。</p><h2 id="tests- 或 -examples">tests 或 examples</h2><p> 有的库会带有测试程序，放在 tests 或 examples 里面。这样修改了前面的文件后，这里面的 <a href="http://Makefile.am" target="_blank" rel="noopener">Makefile.am</a> 也需要进行修改。</p><ol><li> 相应的库文件 <code>libxxx.a</code> 改成 <code>libxxx.so</code></li><li> 链接的库路径从 <code>-L../lib/</code> 改成 <code>-L../lib/.libs</code>，因为 生成的库文件存放在 <code>lib/.libs</code> 目录下。</li></ol><h2 id="重新生成 -configure"> 重新生成 configure</h2><p> 在做完上面的工作后，需要做的是重新生成 <code>configure</code> 文件:</p><pre class=" language-language-bash"><code class="language-language-bash">autoreconf -i</code></pre><p> 之后编译时加上 <code>--enable-shared</code> 选项即可。</p><h2 id="转换过程中的问题"> 转换过程中的问题 </h2><ol><li> 若 <code>configure.ac</code> 中有 <code>AC_CHECK_TOOL(AR, ar, [ar])</code> 语句，要将添加的内容放在这句后面，或去掉这一句。</li><li> 若有其他依赖库，比如放在 <code>other_libs</code> 下面，这些也是需要做相应修改的。</li><li>qdpxx 需要从 master 分支转到 devel 分支。</li><li> 若有可执行程序， 比如在 <code>mainprog</code> 目录下， <code>mainprog</code> 下的 <a href="http://Makefile.am" target="_blank" rel="noopener">Makefile.am</a> 也需要进行相应修改。</li><li> 有的库会在 configure 时，没有正常获取 include 目录，需要手动加上, 在 <code>lib/Makefile</code> 中的 <code>DEFAULT_INCLUDES</code> 选项。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要将几个静态编译的包改成动态编译的库，幸运的是，它们都是用 autoconf 那一套工具生成 configure 文件，转换起来很方便。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://amito.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://amito.me/tags/Linux/"/>
    
      <category term="Automake" scheme="https://amito.me/tags/Automake/"/>
    
      <category term="Chroma" scheme="https://amito.me/tags/Chroma/"/>
    
      <category term="QUDA" scheme="https://amito.me/tags/QUDA/"/>
    
  </entry>
  
  <entry>
    <title>Find What Ports Are Listening in Linux</title>
    <link href="https://amito.me/2019/Find-What-Ports-Are-Listening-in-Linux/"/>
    <id>https://amito.me/2019/Find-What-Ports-Are-Listening-in-Linux/</id>
    <published>2019-03-12T03:41:45.000Z</published>
    <updated>2020-04-13T03:20:25.720Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Sometimes we need to know which program is using the port like 80 port, and this post will show you how to find the program occuping the specific port.</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="参考"> 参考 </h2><ol><li><a href="http://www.linuxandubuntu.com/home/what-are-ports-how-to-find-open-ports-in-linux" target="_blank" rel="noopener">What Are Ports? How To Check Linux Open Ports?</a></li><li><a href="https://www.tecmint.com/find-listening-ports-linux/" target="_blank" rel="noopener">4 Ways to Find Out What Ports Are Listening in Linux</a></li><li><a href="https://www.cyberciti.biz/faq/what-process-has-open-linux-port/" target="_blank" rel="noopener">Linux Find Out Which Process Is Listening Upon a Port</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sometimes we need to know which program is using the port like 80 port, and this post will show you how to find the program occuping the specific port.&lt;/p&gt;
    
    </summary>
    
    
      <category term="vGPU" scheme="https://amito.me/tags/vGPU/"/>
    
      <category term="NVIDIA" scheme="https://amito.me/tags/NVIDIA/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux KVM 中使用 NVIDIA vGPU</title>
    <link href="https://amito.me/2019/Using-NVIDIA-vGPU-in-Linux-KVM/"/>
    <id>https://amito.me/2019/Using-NVIDIA-vGPU-in-Linux-KVM/</id>
    <published>2019-02-20T12:56:24.000Z</published>
    <updated>2020-04-13T03:20:25.742Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 当前 CPU 虚拟化是非常普遍了。 xxx。这篇博文将记录如何在 RHEL/CentOS 下使用 NVIDIA 的 Virtual GPU。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="获取 -NVIDIA-vGPU- 软件"> 获取 NVIDIA vGPU 软件 </h2><h2 id="安装配置 -License-Server"> 安装配置 License Server</h2><h3 id="安装准备工作"> 安装准备工作 </h3><p> 作为 License server，</p><ol><li> 必须有固定的 IP 地址 </li><li> 至少一个不变的以太网 MAC 地址。</li><li> 准确的时间，推荐 NTP。</li></ol><p>License server 依赖于：</p><ol><li>Java Runtime Environment</li><li>tomcat 和 tomcat-webapps</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum install java tomcat tomcat-webapps$ sudo systemctl enable --now tomcat</code></pre><p> 如果安装成功， 访问 <code>localhost:8080</code>, 会看到如下类似的页面，</p><div class="figure center" style="width:;"><img class="fig-img" src="tomcat.png" alt=""></div><h3 id="Linux- 下安装 -License-Server">Linux 下安装 License Server</h3><p> 解压下载的 NVIDIA License Server 包如 <code>NVIDIA-ls-linux-2018.10.0.25098346.zip</code></p><pre class=" language-language-bash"><code class="language-language-bash">$ unzip NVIDIA-ls-linux-2018.10.0.25098346.zip && cd NVIDIA-ls-linux-2018.10.0.25098346$ sh setup.bin</code></pre><p> 安装结束后，访问 <code>http://localhost:8080/licserver</code>, 应该就能看到如下的页面：</p><div class="figure center" style="width:;"><img class="fig-img" src="licserver.png" alt=""></div><h2 id="安装配置 -Host- 宿主机"> 安装配置 Host 宿主机 </h2><p> 我们需要在宿主机上安装 NVIDIA vGPU Manager 软件，登陆 NVIDIA Enterprise 后，可以下载 <code>NVIDIA vGPU for RHEL KVM</code> 或 <code>NVIDIA vGPU for Linux KVM</code>，安装里面的 <code>NVIDIA-vGPU-rhel-7.5-410.91.x86_64</code> 或 <code>NVIDIA-Linux-x86_64-410.91-vgpu-kvm</code> 到 Host 宿主机。</p><h2 id="安装配置 -Guest- 虚拟机"> 安装配置 Guest 虚拟机 </h2><h2 id="需要注意的事情"> 需要注意的事情 </h2><h4 id="虚拟的 -GPU- 在宿主机重启后会消失"> 虚拟的 GPU 在宿主机重启后会消失 </h4><p> 每次重启后， vGPU 都需要重新生成，可能有设置使其得以保存。目前需要将 vGPU id 保存下来，宿主机重启后，依照原来的 vGPU ids 来创建 vGPU， 这样分配到各虚拟机的 vGPU 就不需要再进行更改。</p><h4 id="License-Server- 重启后可能需要重新进行配置">License Server 重启后可能需要重新进行配置 </h4><p>LS 重启后，有可能与绑定的网卡解绑了，需要手动确认，然后重新进行配置。(-_-)</p><h2 id="参考文献"> 参考文献 </h2><ol><li><a href="https://docs.nvidia.com/grid/latest/grid-vgpu-release-notes-generic-linux-kvm/index.html" target="_blank" rel="noopener">Virtual GPU Software R390 for Linux with KVM Release Notes</a></li><li><a href="https://docs.nvidia.com/grid/latest/grid-vgpu-user-guide/index.html#red-hat-el-kvm-install-configure-vgpu" target="_blank" rel="noopener">Virtual GPU Software User Guide</a></li><li><a href="https://docs.nvidia.com/grid/latest/grid-vgpu-release-notes-red-hat-el-kvm/index.html" target="_blank" rel="noopener">Virtual GPU Software R410 for Red Hat Enterprise Linux with KVM Release Notes</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/virtualization_deployment_and_administration_guide/sect-device-gpu" target="_blank" rel="noopener">RedHat: 16.7. ASSIGNING GPU DEVICES</a></li><li><a href="https://docs.openstack.org/nova/latest/admin/virtual-gpu.html" target="_blank" rel="noopener">OpenStack Docs: Attaching virtual GPU devices to guests</a></li><li><a href="https://specs.openstack.org/openstack/nova-specs/specs/queens/implemented/add-support-for-vgpu.html" target="_blank" rel="noopener">OpenStack Docs: Support virtual GPU resources</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当前 CPU 虚拟化是非常普遍了。 xxx。这篇博文将记录如何在 RHEL/CentOS 下使用 NVIDIA 的 Virtual GPU。&lt;/p&gt;
    
    </summary>
    
      <category term="KVM" scheme="https://amito.me/categories/KVM/"/>
    
    
      <category term="KVM" scheme="https://amito.me/tags/KVM/"/>
    
      <category term="QEMU" scheme="https://amito.me/tags/QEMU/"/>
    
      <category term="vGPU" scheme="https://amito.me/tags/vGPU/"/>
    
  </entry>
  
  <entry>
    <title>利用 Grafana 监控 Ceph 集群的状态和性能</title>
    <link href="https://amito.me/2019/Monitor-Ceph-Cluster-Status-and-Performance-with-Grafana/"/>
    <id>https://amito.me/2019/Monitor-Ceph-Cluster-Status-and-Performance-with-Grafana/</id>
    <published>2019-02-14T04:43:37.000Z</published>
    <updated>2020-04-13T03:20:25.725Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Grafana 是一套开源的跨平台的可视化工具，可以将采集的数据进行可视化展示，并进行通知，展示方式多样，能够让我们随时掌控系统的运行情况。这里我们介绍如何使用 Grafana 来对 Ceph 集群进行性能和运行状态的监控。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="在 -CentoS-7- 下安装 -Grafana">在 CentoS 7 下安装 Grafana</h2><p>最简单的方法是通过 Grafana 的官方 Repo 来安装 Grafana。</p><ol><li>添加 grafana repo</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ cat << EOF | sudo tee /etc/yum.repos.d/grafana.repo[grafana]name=grafanabaseurl=https://packagecloud.io/grafana/stable/el/7/repo_gpgcheck=1enabled=1gpgcheck=1gpgkey=https://packagecloud.io/gpg.key https://grafanarel.s3.amazonaws.com/RPM-GPG-KEY-grafanasslverify=1sslcacert=/etc/pki/tls/certs/ca-bundle.crtEOF</code></pre><ol start="2"><li>安装 grafana</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum install -y grafana</code></pre><ol start="3"><li>启动 Grafana：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo systemctl enable --now grafana-server</code></pre><ol start="4"><li>设置防火墙，打开 3000 端口：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo firewall-cmd --permanent --add-port=3000/tcp$ sudo firewall-cmd --reload</code></pre><ol start="5"><li>在浏览器中访问 <code>server-ip:3000</code> 就可以看到 Grafana 界面了。默认用户和组都是 <code>admin</code>。</li></ol><p>Grafana 默认配置文件在 <code>/etc/grafana/grafana.in</code>, 数据库在 <code>/var/lib/grafana/grafana.db</code>, log 存储在 <code>/var/log/grafana</code>。</p><h2 id="使用 -Telegraf- 和 -InfluxDB- 监控 -Ceph">使用 Telegraf 和 InfluxDB 监控 Ceph</h2><p>to be updated…</p><h2 id="利用 -Prometheus- 监控 -Ceph">利用 Prometheus 监控 Ceph</h2><p>我们需要安装 Prometheus 和 ceph-exporter 来为 Grafana 提供 Ceph 的信息，</p><h3 id="在 -CentoS-7- 下安装 -Prometheus">在 CentoS 7 下安装 Prometheus</h3><ol><li>创建一个 Prometheus 系统组和账户：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">### uid, gid < 1000$ sudo useradd -s /sbin/nologin -r -U prometheus### </code></pre><ol start="2"><li>创建 Prometheus 数据和配置文件夹</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo mkdir -p /etc/prometheus/{rules,rules.d}$ sudo mkdir -p /var/lib/prometheus</code></pre><ol start="3"><li>下载最新的 Prometheus 二进制包进行安装(2。7.1)</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ VER=2.7.1$ wget https://github.com/prometheus/prometheus/releases/download/v${VER}/prometheus-${VER}.linux-amd64.tar.gz$ tar xf prometheus-${VER}.linux-amd64.tar.bz2 && cd prometheus-${VER}.linux-amd64### binary$ sudo cp prometheus promtool /usr/bin/### configuration$ sudo cp -r consoles console_libraries prometheus.yml /etc/prometheus### permissions$ sudo chown -R prometheus:prometheus /var/lib/prometheus /etc/prometheus/</code></pre><ol start="4"><li>创建 Prometheus 配置文件:</li></ol><pre class=" language-language-yml"><code class="language-language-yml"># Global configglobal:  scrape_interval: 15s  evaluation_interval: 15s  scrape_timeout: 15sscrape_configs:  - job_name: 'prometheus'    static_configs:  - targets: ['localhost:9090']</code></pre><ol start="5"><li>创建 systemd 服务单元 <code>prometheus.service</code>, 其中，<code>Environment="GOMAXPROCS=2"</code> 是服务器上的 vCPUs 数量:</li></ol><pre class=" language-language-bash"><code class="language-language-bash">[Unit]Description=PrometheusDocumentation=https://prometheus.io/docs/introduction/overview/Wants=network-online.targetAfter=network-online.target[Service]Type=simpleEnvironment="GOMAXPROCS=2"User=prometheusGroup=prometheusExecReload=/bin/kill -HUP $MAINPIDExecStart=/usr/bin/prometheus \  --config.file=/etc/prometheus/prometheus.yml \  --storage.tsdb.path=/var/lib/prometheus \  --web.console.templates=/etc/prometheus/consoles \  --web.console.libraries=/etc/prometheus/console_libraries \  --web.listen-address=0.0.0.0:9090 \  --web.external-url=SyslogIdentifier=prometheusRestart=always[Install]WantedBy=multi-user.target</code></pre><ol start="6"><li>启动 Prometheus 服务：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo cp prometheus.service /usr/lib/systemd/system$ sudo systemctl daemon-reload$ sudo systemctl enable --now prometheus</code></pre><ol start="7"><li>配置防火墙，打开相应的端口</li></ol><pre class=" language-language-bash"><code class="language-language-bash">### open to all ip$ sudo firewall-cmd --permanent --add-port=9090/tcp### open to subnets$ sudo firewall-cmd --permanent --add-rich-rule 'rule family="ipv4" source address="192.168.60.0/24" port protocol="tcp" port="9090" accept'$ sudo firewall-cmd --reload</code></pre><h3 id="安装 -Docker">安装  Docker</h3><p>在用作 Docker 服务器上安装 Docker：</p><ol><li>移除之前安装的 Docker：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum remove -y docker docker-common docker-selinux docker-engine</code></pre><ol start="2"><li>安装依赖包</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><ol start="3"><li>添加 Docker 源：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo wget https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker.repo</code></pre><ol start="4"><li>安装 Docker CE:</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum install docker-ce</code></pre><ol start="5"><li>启动 Docker 服务：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo systemctl enable --now docker</code></pre><h3 id="构建 -Ceph-exporter- 镜像">构建 Ceph-exporter 镜像</h3><ol><li>从 Github clone <code>ceph-exporter</code>：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ git clone https://github.com/digitalocean/ceph_exporter</code></pre><ol start="2"><li>构建 ceph-exporter 镜像：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ docker build . -t ceph-exporter</code></pre><ol start="3"><li>启动一个 Docker 容器运行 Ceph-exporter：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">### 1. docker run:$ docker run --name ceph-exporter -v /etc/ceph:/etc/ceph --net host -p 9128:9128 --restart unless-stopped -dit digitalocean/ceph-exporter### 2. docker-compose:$ cat << EOF >> docker-compose.yml# Example usage of exporter in useversion: '2'services:  ceph-exporter:    image: ceph_exporter    restart: unless-stopped    network_mode: "host"    volumes:        - /etc/ceph:/etc/ceph    ports:        - '9128:9128'EOF$ docker-compose up -d### 3. systemd:$ cat << EOF | sudo tee /usr/lib/systemd/system/ceph-exporter.service[Service]Restart=alwaysTimeoutStartSec=0ExecStartPre=-/usr/bin/docker kill ceph_exporterExecStartPre=-/usr/bin/docker rm ceph_exporterExecStart=/usr/bin/docker run \--name ceph_exporter \-v /etc/ceph:/etc/ceph \--net host \-p 9128:9128 \ceph_exporterExecStop=-/usr/bin/docker kill ceph_exporterExecStop=-/usr/bin/docker rm ceph_exporterEOF$ sudo systemctl daemon-reload $ sudo systemctl enable ceph-exporter$ sudo systemctl status ceph-exporter</code></pre><ol start="4"><li>设置防火墙，打开 9128 端口：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo firewall-cmd --permanent --add-rich-rule 'rule family="ipv4" \source address="192.168.60.0/24" port protocol="tcp" port="9128" accept'$ sudo firewall-cmd --reload</code></pre><ol start="5"><li>Grafana 配置文件中加入 <code>ceph-exporter</code> 部分，修改 <strong>ceph-exporter-ip</strong> 为真实的 IP.IP，并 <strong> 重启</strong> Grafana 服务。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">scrape_configs:    - job_name: prometheus      static_configs:          - targets: ['localhost:9090']    - job_name: 'ceph-exporter'      static_configs:        - targets: ['ceph-exporter-ip:9128']          labels:            alias: ceph-exporter</code></pre><h3 id="将 -Prometheus- 数据添加到 -Grafana">将 Prometheus 数据添加到 Grafana</h3><p>安装配置好上面的之后，我们需要在 Grafana 中添加 Prometheus 数据源。<br>登陆到 Grafana Web 服务器，在设置中，添加数据源，选择 Prometheus：</p><div class="figure center" style="width:;"><img class="fig-img" src="grafana-data-source.png" alt=""></div><p>添加数据源，需要提供的是：</p><ul><li>Name： 数据源名</li><li>URL: 数据源地址</li><li>Access: Server(Proxy) or Browser(Direct)</li></ul><p>添加界面如下：</p><div class="figure center" style="width:;"><img class="fig-img" src="grafana-prometheus.png" alt=""></div><p>填好后，点击 <code>Save and Test</code> 按钮即可。</p><h3 id="启用 -Ceph- 的 -Prometheus- 模块">启用 Ceph 的 Prometheus 模块</h3><p>在 Ceph 中启用 mgr 的 promtheus 监控模块：</p><pre class=" language-language-bash"><code class="language-language-bash">$ ceph mgr module enable prometheus</code></pre><h3 id="导入 -Ceph- 集群的 -Grafana-Dashboards">导入 Ceph 集群的 Grafana Dashboards</h3><p><a href="https://grafana.com/dashboards" target="_blank" rel="noopener">Grafana</a> 官网上有一些已经写好的 Dashboards， 我们可以从上面导入一些设计比较好的。 Dashboard 是 json 文件，我们也可以自己修改设计 Ceph 的 Dashboard。Ceph 本身也有一些 <a href="https://github.com/ceph/ceph/tree/master/monitoring/grafana/dashboards" target="_blank" rel="noopener">Dashboards</a>, 可以作为参考。<br>在 Grafana Web 界面左侧的工具栏选择 <strong>+ -&gt; Import</strong>，导入界面大致如下：</p><div class="figure center" style="width:;"><img class="fig-img" src="grafana-import.png" alt=""></div><p>有三种方法可以导入 Dashboard：</p><ul><li>填写 Dashboard 在 <a href="http://Grafana.com" target="_blank" rel="noopener">Grafana.com</a> Dashboard 中的 url 或 id</li><li>上传 JSON 文件</li><li>直接粘贴 JSON 内容</li></ul><p>导入合适的 Dashboard 后，就可以在 Dashboards 界面选择查看导入的 Dashboards 了。</p><p><strong>PS</strong>: <a href="https://github.com/digitalocean/ceph_exporter" target="_blank" rel="noopener">ceph-exporter</a> 中提供了 <code>docker-compose.yml</code>，包含了 Prometheus、Grafana 和 ceph-exporter， 我们可以使用 docker-compose 一起运行这三个服务。</p><h2 id="参考">参考</h2><ol><li><a href="https://grafana.com/dashboards/7056" target="_blank" rel="noopener">Grafana Ceph - Cluster 7056</a></li><li><a href="https://grafana.com/dashboards/2842" target="_blank" rel="noopener">Grafana Ceph - Cluster 2842</a></li><li><a href="https://grafana.com/dashboards/917" target="_blank" rel="noopener">Grafana Ceph - Cluster 917</a></li><li><a href="https://grafana.com/dashboards/923" target="_blank" rel="noopener">Grafana Ceph - Cluster 923</a></li><li><a href="https://grafana.com/dashboards/926" target="_blank" rel="noopener">Grafana Ceph - Cluster 926</a></li><li><a href="https://computingforgeeks.com/monitoring-ceph-cluster-with-prometheus-and-grafana/" target="_blank" rel="noopener">Monitoring Ceph Cluster with Prometheus and Grafana</a></li><li><a href="http://docs.ceph.com/docs/mimic/mgr/prometheus/" target="_blank" rel="noopener">Prometheus plugin</a></li><li><a href="https://github.com/ceph/ceph/tree/master/monitoring" target="_blank" rel="noopener">Ceph Monitoring</a></li><li><a href="https://computingforgeeks.com/install-prometheus-server-on-centos-7/" target="_blank" rel="noopener">Install Prometheus Server on CentOS 7 and Ubuntu 18.04</a></li><li><a href="https://computingforgeeks.com/monitoring-ceph-cluster-with-prometheus-and-grafana/" target="_blank" rel="noopener">Monitoring Ceph Cluster with Prometheus and Grafana</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Grafana 是一套开源的跨平台的可视化工具，可以将采集的数据进行可视化展示，并进行通知，展示方式多样，能够让我们随时掌控系统的运行情况。这里我们介绍如何使用 Grafana 来对 Ceph 集群进行性能和运行状态的监控。&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="https://amito.me/categories/Ceph/"/>
    
    
      <category term="Ceph" scheme="https://amito.me/tags/Ceph/"/>
    
      <category term="Grafana" scheme="https://amito.me/tags/Grafana/"/>
    
  </entry>
  
  <entry>
    <title>GPU 虚拟化与云计算</title>
    <link href="https://amito.me/2019/GPU-Virtualizations-and-Cloud-Computing/"/>
    <id>https://amito.me/2019/GPU-Virtualizations-and-Cloud-Computing/</id>
    <published>2019-01-22T08:55:44.000Z</published>
    <updated>2020-04-13T03:20:25.720Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 目前 GPU 在 HPC 和云计算中占据着越来越重要的位置。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="GPU- 虚拟化历史">GPU 虚拟化历史 </h2><h2 id="GPU- 虚拟化现状">GPU 虚拟化现状 </h2><h2 id="vGPU- 之 -NVIDIA">vGPU 之 NVIDIA</h2><h2 id="vGPU- 之 -AMD">vGPU 之 AMD</h2><h2 id="vGPU- 之 -Intel">vGPU 之 Intel</h2><h2 id="OpenStack- 中的 -GPU- 虚拟化 -to-update">OpenStack 中的 GPU 虚拟化 (to-update)</h2><p> 目前 OpenStack 已经可以支持 GPU 虚拟化 vGPU，但是尚处于实验阶段。OpenStack 从 <code>Queens</code> 版本开始支持 vGPU，目前开发版本是 <code>Stein</code>, 与 vGPU 相关的计划和进展可在 <a href="https://blueprints.launchpad.net/nova/+spec/vgpu-stein" target="_blank" rel="noopener"> 这里 </a> 找到。</p><h2 id="文献参考"> 文献参考 </h2><ol><li><a href="https://yq.aliyun.com/articles/578724" target="_blank" rel="noopener">【技术系列】浅谈 GPU 虚拟化技术 - 孟蓁蓁 </a></li><li><a href="https://docs.openstack.org/nova/rocky/admin/virtual-gpu.html" target="_blank" rel="noopener">Attaching virtual GPU devices to guests - OpenStack</a></li><li><a href="https://gist.github.com/claudiok/890ab6dfe76fa45b30081e58038a9215" target="_blank" rel="noopener">Consumer-grade GPU passthrough in an OpenStack system (NVIDIA GPUs)</a></li><li><a href="http://www.brightcomputing.com/blog/setting-up-gpu-hypervisors-on-bright-openstack" target="_blank" rel="noopener">Setting up GPU Hypervisors on OpenStack</a></li><li><a href="https://www.forbes.com/sites/tiriasresearch/2018/05/23/virtual-gpus-in-openstack-filling-a-hole-in-the-cloud-machine-learning-world/#5e32e3d85999" target="_blank" rel="noopener">Virtual GPUs In OpenStack: Filling A Hole In The Cloud Machine Learning World</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前 GPU 在 HPC 和云计算中占据着越来越重要的位置。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="https://amito.me/categories/OpenStack/"/>
    
    
      <category term="OpenStack" scheme="https://amito.me/tags/OpenStack/"/>
    
      <category term="vGPU" scheme="https://amito.me/tags/vGPU/"/>
    
      <category term="Virtualization" scheme="https://amito.me/tags/Virtualization/"/>
    
      <category term="CUDA" scheme="https://amito.me/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>XCache 的配置、测试与优化</title>
    <link href="https://amito.me/2019/XCache-Config-Testing-And-Optimizing/"/>
    <id>https://amito.me/2019/XCache-Config-Testing-And-Optimizing/</id>
    <published>2019-01-04T02:51:47.000Z</published>
    <updated>2020-04-13T03:20:25.758Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>XRoodD is the common protocol generally used in high energy physics computing. XRootD proxy for file cache(XCache) is a typical way for XRootD.</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="XRootD- 代理服务">XRootD 代理服务 </h2><h3 id="XRootD- 直接代理模式">XRootD 直接代理模式 </h3><h3 id="XRootD- 转发代理模式">XRootD 转发代理模式 </h3><h3 id="XRootD- 联合代理模式">XRootD 联合代理模式 </h3><h3 id="XRootD- 自动代理">XRootD 自动代理 </h3><h2 id="XRootD- 代理缓存服务">XRootD 代理缓存服务 </h2><h3 id="XRootD- 磁盘缓存模式">XRootD 磁盘缓存模式 </h3><p>XRootD 自带了几个简单的文件缓存配置 - <code>xrootd-filecache-cluster.cf</code> 和 <code>xrootd-filecache-standalone.cfg</code>, 下面是一个磁盘缓存模式 <code>Disk Cache</code> 的配置文件:</p><pre class=" language-language-bash"><code class="language-language-bash">all.export /ofs.osslib libXrdPss.soxrootd.trace emsg login stall redirectxrd.trace infoofs.trace infopss.origin = some_server:1094### 包含 Disk Cache Proxy 插件的共享库。pss.cachelib  libXrdFileCache.so### 用来缓存需要写到磁盘上的代理缓冲的最大允许 RAM。超过这个值，代理会将请求发送到远程服务器。pfc.ram   16gpss.setopt DebugLevel 0oss.memfile max 80% check map preload### 用来保存缓存文件的位置oss.localroot  /datapfc.trace  DebugLevelpfc.prefetch  8pfc.blocksize  512kofs.ckslib * libXrdPss.sopfc.user xrootd</code></pre><h3 id="XRootD- 内存缓存模式">XRootD 内存缓存模式 </h3><p> 与 <code>Disk Cache</code> 模式不同的是，XRootD 内存缓存模式 <code>Memory Cache</code> 是将最近访问过的文件缓存在内存中，所以要求作为服务器的内存要足够大。 XRootD <code>Disk Cache</code>  与  <code>Memory Cache</code> 是不能共存的。 XRootD Memory Cache 与标准的 XRoot Proxy 服务 相比，只多了一个 <code>pss.cahce</code> 语句。 下面是一个 Memory Cahce 的配置文件。</p><pre class=" language-language-bash"><code class="language-language-bash">all.export /ofs.osslib libXrdPss.soxrootd.trace emsg login stall redirectxrd.trace infoofs.trace infopss.origin = some_server:1094pss.cache logstats max2cache 16g sfiles on r prereadpss.setopt DebugLevel 0</code></pre><h2 id="XCache- 测试">XCache 测试 </h2><h2 id="参考"> 参考 </h2><ol><li><a href="http://xrootd.org/doc/dev47/pss_config.htm" target="_blank" rel="noopener">Proxy Storage Services (Caching, Non-Caching, &amp; Server-less Caching) Configuration Reference</a></li><li><a href="https://doi.org/10.1088/1742-6596/513/4/042044" target="_blank" rel="noopener">XRootd, disk-based, caching proxy for optimization of data access, data placement and data replication</a></li><li><a href="https://twiki.cern.ch/twiki/bin/view/AtlasComputing/Tier3gXrootdSetup" target="_blank" rel="noopener">Installing and configuring xrootd</a></li><li><a href="https://www.researchgate.net/publication/328387441_A_federated_Xrootd_cache" target="_blank" rel="noopener">A fedorated Xrootd Cache</a></li><li><a href="https://opensciencegrid.org/StashCache/admin/install/" target="_blank" rel="noopener">Stash Cache Installation</a></li><li><a href="https://indico.nikhef.nl/event/1318/session/1/contribution/10/material/slides/0.pdf" target="_blank" rel="noopener">Distributed and on-demand cache for CMS experiment at LHC</a></li><li><a href="https://gitlab.ekp.kit.edu/ETP-HTC/XRootD-Caching-Setup/tree/master" target="_blank" rel="noopener">XRootD-Caching-Setup</a></li><li><a href="https://indico.egi.eu/indico/event/3973/contribution/97" target="_blank" rel="noopener">The adoption of the HTTP/XRootD protocols for a new data caching architecture in WLCG experiments</a></li><li><a href="http://digitalcommons.unl.edu/cgi/viewcontent.cgi?article=1003&amp;context=hollandfacpub" target="_blank" rel="noopener">Distributed Caching Using the HTCondor CacheD</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XRoodD is the common protocol generally used in high energy physics computing. XRootD proxy for file cache(XCache) is a typical way for XRootD.&lt;/p&gt;
    
    </summary>
    
      <category term="EOS" scheme="https://amito.me/categories/EOS/"/>
    
    
      <category term="EOS" scheme="https://amito.me/tags/EOS/"/>
    
      <category term="XRootD" scheme="https://amito.me/tags/XRootD/"/>
    
  </entry>
  
  <entry>
    <title>将 Ceph 文件系统 CephFS 挂载为 NFS</title>
    <link href="https://amito.me/2019/Mount-CephFS-over-NFS/"/>
    <id>https://amito.me/2019/Mount-CephFS-over-NFS/</id>
    <published>2019-01-04T02:05:37.000Z</published>
    <updated>2020-04-13T03:20:25.728Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 利用 NFS-Ganesha 或 ceph-fuse 与 nfsd， 我们可以将 CephFS 通过 NFS 协议对外发布出去，用户可以通过 NFS 客户端挂载 CephFS 文件系统进行访问。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="Ceph- 与 -NFS">Ceph 与 NFS</h2><p>Ceph 是一种开源的分布式存储系统，具有优异的性能、可靠性和可扩展性。 Ceph 底层使用 RADOS，提供 RBD、RGW 和 CephFS 三种标准的访问接口。从 Luminous 版本开始， CephFS 已经具有相当好的稳定性，可用在生产环境。</p><div class="figure center" style="width:;"><img class="fig-img" src="ceph.png" alt="Ceph 架构"><span class="caption">Ceph 架构 </span></div><p>NFS (Network File System) 是常用的网络文件系统，用户通过 NFS 可以像访问本地文件一样访问远程的文件，NFS 服务端和客户端之间通过 NFS 协议进行通信。</p><p> 用户可以用 Ceph 提供的 ceph-fuse 挂载 CephFS 进行访问，也可以通过 ceph 的内核模块进行挂载访问，具体可参考 <a href="/2018/CephFS-Introduction-Installation-and-Configuration/">Ceph 文件系统 CephFS 的介绍与配置 </a>。 但有时候，由于各种原因，一些系统无法通过这两种方法访问 CephFS，我们可以将 CephFS 通过 NFS 协议发布出去，用户可以通过 NFS 客户端挂载发布出去的 CephFS。</p><h2 id="NFS-Ganesha- 挂载 -CephFS">NFS-Ganesha 挂载 CephFS</h2><p>CephFS 可以通过 <a href="https://github.com/nfs-ganesha/nfs-ganesha/wiki" target="_blank" rel="noopener">NFS-Ganesha</a> 使用 NFS 协议发布出去。</p><h3 id="准备条件"> 准备条件 </h3><ul><li> 一个设置好的 CephFS 文件系统 </li><li> 在 NFS 服务器上，安装 <code>libcephfs2</code>、<code>nfs-ganesha</code> 和 <code>nfs-ganesha-ceph</code> (ganesha &gt;= 2.5) 包。</li><li>NFS-Ganesha 服务器与 CephFS 网路相连。</li></ul><h3 id="安装 -NFS-Ganesha"> 安装 NFS-Ganesha</h3><ol><li> 通过包管理器安装：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum install nfs-ganesha-fsal-ceph</code></pre><ol start="2"><li> 通过源码安装：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ mkdir -p ~/tmp/ && cd ~/tmp$ git clone https://github.com/nfs-ganesha/nfs-ganesha.git$ mkdir build && cd build$ cmake -DUSE_FSAL_CEPH=ON ../nfs-ganesha$ make && sudo make install</code></pre><h3 id="配置 -NFS-Ganesha"> 配置 NFS-Ganesha</h3><ol><li> 关闭防火墙或打开 <code>2049</code> 端口：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">### turn off firewall$ sudo systemctl disable --now firewalld$ sudo systemctl disable --now iptables### or open port 2049$ sudo firewall-cmd --permanent --add-port=2049/tcp$ sudo firewall-cmd --reload</code></pre><ol start="2"><li> 启动 <code>rpcbind</code> 和 <code>rpcstatd</code> 服务：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo systemctl enable --now rpcbind$ sudo systemctl enable --now rpcstatd</code></pre><ol start="3"><li> 复制 Ceph 配置文件到 <code>/etc/ceph/ceph.conf</code></li><li> 根据 NFS-Ganesha 的 <a href="https://github.com/nfs-ganesha/nfs-ganesha/blob/next/src/config_samples/ceph.conf" target="_blank" rel="noopener">Ceph 配置例子 </a>， 创建 <code>/etc/ganashe/ceph.conf</code>，类似如下:</li></ol><pre class=" language-language-bash"><code class="language-language-bash">NFS_CORE_PARAM{Enable_NLM = false;Enable_RQUOTA = false;Protocols = 4;}NFSv4{    Allow_Numeric_Owners = true;    Only_Numeric_Owners = true;Delegations = active;}CACHEINODE{Dir_Chunk = 0;NParts = 1;Cache_Size = 1;}EXPORT{Export_ID = 1;Protocols = 4;Transports = TCP;Path = /;Pseudo = /cephfs/;Access_type = RW;Delegations = RW;# Squash = root;FSAL{NAME = CEPH;}}</code></pre><ol start="5"><li> 启动 NFS-Ganesha 服务：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo ganesha.nfsd -f /etc/ganesha/ceph.conf -L /var/log/ganesha.log -N NIV_CRIT$ sudo showmount -e</code></pre><p> 这样就把 CephFS 通过 NFS 协议导出了。值得注意的是，<strong> 目前一个运行的 Ganesha 进程只能导出一个 CephFS 中的一个目录 </strong>；如果多个 CephFS 或 一个 CephFS 中的多个目录需要导出，需要有相应多个 Ganesha 进程 </p><h3 id="NFS- 客户端挂载">NFS  客户端挂载 </h3><p> 在 NFS 客户端服务器上挂载 CephFS 到 <code>/cephfs</code></p><pre class=" language-language-bash"><code class="language-language-bash">### Usage:$ sudo mount -t nfs4 -o nfsvers=4.1,protoc=tcp,rw,notime <ganesha-host>:<ganesha-pseudo-path> <mount-point>### e.g.:$ sudo mount -t nfs4 -o nfsvers=4.1,proto=tcp,rw,notime <ganesha-host>:/ /cephfs</code></pre><p> 这样用户就可以通过 NFS 协议访问 CephFS 了。</p><h2 id="ceph-fuse- 和 -nfsd- 挂载 -CephFS">ceph-fuse 和 nfsd 挂载 CephFS</h2><p>Ceph 提供了 <code>ceph-fuse</code> 来挂载和访问 CephFS。在 NFS 服务器上通过 <code>ceph-fuse</code> 挂载 CephFS 后，我们可以通过 nfsd 将其发布出去。</p><h3 id="NFS- 服务端设置">NFS 服务端设置 </h3><ol><li> 在 NFS 服务器上挂载 CephFS。</li><li> 在 <code>/etc/exports</code> 中添加如下内容:</li></ol><pre class=" language-language-bash"><code class="language-language-bash">### Usage:/path/to/mount * (rw,sync,no_root_squash,fsid=ceph-id)### example:/cephfs * (rw,sync,no_root_squash,fsid=87761f6e-f839-4597-bfe2-fd850d9a03cf)</code></pre><ol start="3"><li> 运行 <code>exportfs</code>，并启动 <code>rpcbind</code> 和 <code>nfs-server</code> 服务，将 该节点变成 NFS 服务器。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo exportfs$ sudo systemctl enable --now rpcbind$ sudo systemctl enable --now nfs-server</code></pre><h3 id="NFS- 客户端挂载 -v2">NFS 客户端挂载 </h3><p> 在 NFS 客户端上通过 NFS 协议挂载 CephFS：</p><pre class=" language-language-bash"><code class="language-language-bash">$ sudo mount -t sudo mount -t nfs4 -o nfsvers=4.1,proto=tcp,rw,notime <nfs-host>:/cephfs /cephfs</code></pre><p> 这样用户就可以通过 NFS 协议访问 CephFS 了。</p><h2 id="两种方案对比"> 两种方案对比 </h2><h2 id="参考文献"> 参考文献 </h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzA5NzM3Ng==&amp;mid=2651857179&amp;idx=1&amp;sn=de46bd8b6ff1414b762e983bbe129464&amp;chksm=f32959d4c45ed0c227939f4712c1ed46df2a88763e09dfc95fdd0f8e6da8239bb02f43f25736&amp;scene=21" target="_blank" rel="noopener">NFS+CephFS 构建基于 Ceph 的 NAS 服务 </a></li><li><a href="https://zhoubofsy.github.io/2017/05/25/storage/ceph/ceph-nfs-service-by-rgw-with-nfs-ganesha/" target="_blank" rel="noopener">Ceph 提供 NFS 服务 —— RGW＋nfs-ganesha</a></li><li><a href="http://manjusri.ucsc.edu/2017/10/11/mpi-io-cephfs/" target="_blank" rel="noopener">MPI-IO with CephFS?</a></li><li><a href="https://docs.oracle.com/cd/E52668_01/E96266/html/ceph-luminous-nfs-cephfs.html" target="_blank" rel="noopener">Exporting Ceph FS Over NFS</a></li><li><a href="http://docs.ceph.com/docs/mimic/cephfs/nfs/" target="_blank" rel="noopener">NFS CephFS Using Ganesha</a></li><li><a href="http://docs.ceph.com/docs/mimic/radosgw/nfs/" target="_blank" rel="noopener">NFS RadosGW Using Ganesha</a></li><li><a href="http://cloud.51cto.com/art/201507/482289.htm" target="_blank" rel="noopener"> 以 CephFS 为例解析如何在云中提供 NAS 服务 </a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用 NFS-Ganesha 或 ceph-fuse 与 nfsd， 我们可以将 CephFS 通过 NFS 协议对外发布出去，用户可以通过 NFS 客户端挂载 CephFS 文件系统进行访问。&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="https://amito.me/categories/Ceph/"/>
    
    
      <category term="Ceph" scheme="https://amito.me/tags/Ceph/"/>
    
      <category term="CephFS" scheme="https://amito.me/tags/CephFS/"/>
    
      <category term="NFS" scheme="https://amito.me/tags/NFS/"/>
    
  </entry>
  
  <entry>
    <title>在 OpenStack 中将虚拟机实例转成启动镜像</title>
    <link href="https://amito.me/2018/Convert-An-Instance-to-An-Image-in-OpenStack/"/>
    <id>https://amito.me/2018/Convert-An-Instance-to-An-Image-in-OpenStack/</id>
    <published>2018-12-30T07:21:20.000Z</published>
    <updated>2020-04-13T03:20:25.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 在 OpenStack 中，我们对虚拟机实例做了修改后，可以以此实例为模版创建新的虚拟机镜像，其过程也很简单。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h3 id="创建实例的快照"> 创建实例的快照 </h3><ol><li> 找到将要作为模版的实例，并将其关掉。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ source ~/keystonerc_admin$ nova list...| 8e640acc-6cca-4a4a-8ca5-763150d107bd | my_instance    | ACTIVE  | -          | Running     | V2018=192.168.18.20 |...$ nova stop my_instance</code></pre><ol start="2"><li> 确保实例已经关机。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ nova list...| 8e640acc-6cca-4a4a-8ca5-763150d107bd | my_instance    | ACTIVE  | -          | SHUTOFF     | V2018=192.168.18.20 |...</code></pre><ol start="3"><li> 使用 <code>nova image-create</code> 创建实例快照。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ nova image-create --poll my_instance my_instance_snpServer snapshotting... 100% complete</code></pre><ol start="4"><li> 确保 Nova 镜像处于 <code>ACTIVE</code> 状态。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ nova image-list...| 5c8e13b7-2eea-4bf7-9440-c1e7c603380f | my_instance_snp          | ACTIVE | 8e640acc-6cca-4a4a-8ca5-763150d107bd |...</code></pre><h3 id="下载快照到本地"> 下载快照到本地 </h3><ol><li> 获取快照 ID。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ nova image-list...| 5c8e13b7-2eea-4bf7-9440-c1e7c603380f | my_instance_snp          | ACTIVE | 8e640acc-6cca-4a4a-8ca5-763150d107bd |...</code></pre><ol><li> 将快照下载到本地。使用快照 ID 而不是名字。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ glance image-download --file my_instance_image.qcow2 5c8e13b7-2eea-4bf7-9440-c1e7c603380f</code></pre><ol start="3"><li> 如果需要，将镜像复制到新环境中。</li></ol><h3 id="从快照镜像生成镜像"> 从快照镜像生成镜像 </h3><pre class=" language-language-bash"><code class="language-language-bash">$ glance --os-image-api-version 1 image-create --container-format bare --disk-format qcow2 -name "my_new_image" --file my_instance_image.qcow2### or$ glance --os-image-api-version 1 image-create --container-format bare --disk-format qcow2 -name "my_new_image" --copy_from my_instance_image_url</code></pre><h3 id="从新镜像启动新实例"> 从新镜像启动新实例 </h3><pre class=" language-language-bash"><code class="language-language-bash">$ nova boot --flavor m1.tiny --image my_new_image my_new_instance</code></pre><h3 id="参考"> 参考 </h3><ol><li><a href="https://docs.openstack.org/mitaka/user-guide/cli_use_snapshots_to_migrate_instances.html" target="_blank" rel="noopener">Use snapshots to migrate instances</a></li><li><a href="http://khmel.org/?p=1188" target="_blank" rel="noopener">OpenStack – convert an instance to an image</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 OpenStack 中，我们对虚拟机实例做了修改后，可以以此实例为模版创建新的虚拟机镜像，其过程也很简单。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="https://amito.me/categories/OpenStack/"/>
    
    
      <category term="OpenStack" scheme="https://amito.me/tags/OpenStack/"/>
    
      <category term="Virtualization" scheme="https://amito.me/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title>使用 Pandoc 来制作 HTML 和 beamer 风格的幻灯片</title>
    <link href="https://amito.me/2018/Using-Pandoc-to-Make-HTML-and-Beamer-Slides/"/>
    <id>https://amito.me/2018/Using-Pandoc-to-Make-HTML-and-Beamer-Slides/</id>
    <published>2018-12-28T05:06:46.000Z</published>
    <updated>2020-04-13T03:20:25.744Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Pandoc 是一款开源的文档格式转换工具，能够实现大部分的文件格式互转。这里我们主要用来将 Markdown 文档转换成 HTML 和 PDF 风格的幻灯片。 Markdown 语法、结构简单，只需要写出文档的提纲和结构，就能转换成简洁明了又美观的 Slides。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="Pandoc- 格式转换利器">Pandoc - 格式转换利器</h2><p>Pandoc 是全平台的转换工具，在命令行能够很方便的进行格式转换。 Pandoc 支持的格式及转换方式如下图所示。</p><div class="figure center" style="width:60%;"><img class="fig-img" src="pandoc.png" style="width:60%;" alt=""></div><p>更多的可以打开 <a href="/2018/Using-Pandoc-to-Make-HTML-and-Beamer-Slides/pandoc.jpg"> 这里</a> 查看，可以看到 Pandoc 支持的格式是极多的。</p><p>Pandoc 的安装是非常简单的， 可按照 <a href="http://johnmacfarlane.net/pandoc/installing.html" target="_blank" rel="noopener">说明</a> 很方便地安装到系统中。</p><h2 id="文档语法结构">文档语法结构</h2><p>Pandoc 支持标准的 Markdown 语法，但在结构上与一般的用 Markdown 写博客有点区别。</p><h3 id="元数据">元数据</h3><p>为了让 Pandoc 能渲染 Markdown 文件生成 Slides， 需要在文档头部加上几行元数据信息。</p><pre class=" language-language-markdown"><code class="language-language-markdown">% Title% Author% Tate</code></pre><p>这样就能生成幻灯片的标题页了。</p><h3 id="文档结构">文档结构</h3><p>一般情况下，一个 Markdown 文档只有一个一级标题。 Pandoc 中，默认情况下，一级标题代表 一个章节， 三个一级标题就是把幻灯片分为三部分；二级标题代表一张幻灯片； 三级标题则一般是幻灯片内部的块。 一个基本的文档结构如下所示</p><pre class=" language-language-markdown"><code class="language-language-markdown">% Title% Author% Tate# Part I## slide I- list 1- list 2## slide II1. list 12. list 2# Part II## slide III[amito](amito.me)## slide IV![picture](pic.png)</code></pre><h3 id="数学公式">数学公式</h3><p>Pandoc 支持转换 TeX 数学公式， 能够将数学公式转换成 MathML， 或者通过 MathJax 显示。</p><pre class=" language-language-tex"><code class="language-language-tex">$\frac{a}{b^2+c^3}$$$\frac{a}{b^2+c^3}$$</code></pre><p>显示效果为：$\frac{a}{b<sup>2+c</sup>3}$<br>$$\frac{a}{b<sup>2+c</sup>3}$$</p><h2 id="幻灯片样式">幻灯片样式</h2><p>在 <code>/usr/share/pandoc-xxx/data</code> 下面有 Pandoc 自带的转换模版， html 幻灯片模版有 <code>dszlides</code>, <code>html</code>, <code>html5</code>, <code>revealjs</code>, <code>s5</code>, <code>slideous</code>, <code>slidy</code> 等等。下面简单介绍几种。</p><h3 id="s5">s5</h3><p><a href="http://meyerweb.com/eric/tools/s5/" target="_blank" rel="noopener">s5</a> 是很流行的 HTML 幻灯片模版，可以从网站上下载后使用，也可以在线使用。本地使用主要是其中的 <code>ui/default</code>, 将其复制到 markdown 所在目录。在线使用需要指定 <code>s5-url</code></p><pre class=" language-language-bash"><code class="language-language-bash">#### local$ pandoc -s -t s5 -o s5.html s5.md#### online$ pandoc -s -t s5 -V s5-url=https://cdn.docbook.org/release/xsl-nons/current/slides/s5/ui/default/ -o s5.html s5.md</code></pre><h3 id="reveal-js">reveal.js</h3><p>reveal.js 是非常火的 HTML 幻灯片库，本身支持 Markdown 语法。 离线使用 reveal.js 需要将其下载下来，在线使用可以指定 <code>revealjs-url</code>。<br>下载 <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a></p><pre class=" language-language-bash"><code class="language-language-bash">$ git clone https://github.com/hakimel/reveal.js</code></pre><p>渲染 markdown 文件生成 HTML 幻灯片，在线使用可以通过指定 <code>revealjs-url</code> 来使用。</p><pre class=" language-language-bash"><code class="language-language-bash">$ pandoc -s -t revealjs -o h5.html h5.md$ pandoc -s -t revealjs -V revealjs-url=https://cdnjs.com/libraries/reveal.js/3.6.0 -o h5.htmnl h5.md</code></pre><p>reveal.js 自带了一些模版可供选择，通过 <code>-V css=/path/to/css</code> 来指定自带的或自己定制的模版，</p><pre class=" language-language-bash"><code class="language-language-bash">#### local$ pandoc -s -t revealjs -V css=reveal.js/css/theme/night.css -o h5.html h5.md#### onlineurl="https://cdnjs.com/libraries/reveal.js/3.6.0/"$ pandoc -s -t revealjs -V revealjs-url=$url -V css=$url/css/theme/night.css -V -o h5.html h5.md</code></pre><p>也可以修改 reveal.js 模版 <code>/usr/share/pandoc-xxx/data/templates/default.revealjs</code>。</p><pre class=" language-language-html"><code class="language-language-html">$if(css)$$for(css)$    <link rel="stylesheet" href="$css$"/>$endfor$$else$    <link rel="stylesheet" href="$revealjs-url$/css/theme/simple.css" id="theme">$endif$</code></pre><p>改为</p><pre class=" language-language-html"><code class="language-language-html">$if(css)$$for(css)$    <link rel="stylesheet" href="$revealjs-url$/css/theme/$css$"/>$endfor$$endif$$if(theme)$    <link rel="stylesheet" href="$revealjs-url$/css/theme/$theme$.css" id="theme">$else$    <link rel="stylesheet" href="$revealjs-url$/css/theme/simple.css" id="theme">$endif$</code></pre><p>这样就可以简单指定 <code>theme</code> 了。</p><pre class=" language-language-bash"><code class="language-language-bash">$ pandoc -s -t revealjs -V theme=night -o h5.html h5.md</code></pre><h2 id="Beamer- 样式">Beamer 样式</h2><p>Pandoc 能非常方便地将 markdown 转换为独立的 tex 文档，然后通过 tex 命令 可以生成 pdf 幻灯片。</p><pre class=" language-language-bash"><code class="language-language-bash">$ pandoc -s -t beamer -o slide.tex slide.md$ latexmk -pdf slide.tex</code></pre><h3 id="Beamer- 模版">Beamer 模版</h3><p>Pandoc 有默认的 beamer 模版，使用 platex 编译，如果不喜欢，可以参考默认模版 <code>/usr/share/pandoc-xxx/data/templates/default.beamer</code> 自己定制一个 beamer 模版，网上也有一些现成的模版，可以参考。<br>下面是默认模版生成的幻灯片样式。</p><div class="figure center" style="width:;"><img class="fig-img" src="beamer.png" alt=""></div><h3 id="中文字体">中文字体</h3><ol><li>首先查看系统中文字体：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ fc-list :lang=zh</code></pre><ol start="2"><li>转换时指定字体：</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ pandoc -s -t beamer --pdf-engine=xelatex -V CJKmainfont=KaiTi srs.md -o srs.pdf</code></pre><ol start="3"><li>Markdown 文件中加入设置。默认的 beamer 模版中有 <code>CJKmainfont</code> 变量，指定后会使用 <code>xeCJK</code> 包：</li></ol><pre><code>---CJKmainfont: STSongCJKoptions:  - BoldFont=STHeiti  - ItalicFont=STKaiti---</code></pre><ol start="4"><li>定制模版，这是比较方便的一种方式，能更改的地方也更多，<a href="https://github.com/darkshell/beamer/blob/master/themes/ponde.tex" target="_blank" rel="noopener">这里 </a> 是我根据 <a href="https://github.com/cympfh/beamer" target="_blank" rel="noopener"> 网上</a> 模版修改过的。</li></ol><h2 id="参考">参考</h2><ol><li><a href="https://linux.cn/article-4080-1.html" target="_blank" rel="noopener">Markdown+Pandoc→HTML 幻灯片速成</a></li><li><a href="https://stackoverflow.com/questions/40892725/pandoc-does-not-recognize-chinese-characters" target="_blank" rel="noopener">pandoc does not recognize Chinese characters</a></li><li><a href="https://pandoc.org/demos.html" target="_blank" rel="noopener">Pandoc Demo</a></li><li><a href="https://nval.andreasherten.de/2016/01/26/latex-beamer-with-markdown.html" target="_blank" rel="noopener">Talks with LaTeX Beamer, written in Markdown</a></li><li><a href="https://bl.ocks.org/lmullen/c3d4c7883f081ed8692a" target="_blank" rel="noopener">PDF slides and handouts using Pandoc and Beamer</a></li><li><a href="https://github.com/jgm/pandoc/wiki/User-contributed-templates" target="_blank" rel="noopener">User contributed templates</a></li><li><a href="http://www.bagualu.net/wordpress/archives/5396" target="_blank" rel="noopener">用 pandoc 把 markdown 转化为 pdf 文档</a></li><li><a href="https://jdhao.github.io/2017/12/10/pandoc-markdown-with-chinese/" target="_blank" rel="noopener">纯文本做笔记 — 使用 Pandoc 与 Markdown 生成 PDF 文件</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pandoc 是一款开源的文档格式转换工具，能够实现大部分的文件格式互转。这里我们主要用来将 Markdown 文档转换成 HTML 和 PDF 风格的幻灯片。 Markdown 语法、结构简单，只需要写出文档的提纲和结构，就能转换成简洁明了又美观的 Slides。&lt;/p&gt;
    
    </summary>
    
      <category term="LaTeX" scheme="https://amito.me/categories/LaTeX/"/>
    
    
      <category term="LaTeX" scheme="https://amito.me/tags/LaTeX/"/>
    
      <category term="Beamer" scheme="https://amito.me/tags/Beamer/"/>
    
      <category term="Pandoc" scheme="https://amito.me/tags/Pandoc/"/>
    
  </entry>
  
  <entry>
    <title>为 Nginx 创建自签名的 SSL 证书</title>
    <link href="https://amito.me/2018/Generating-A-Self-Signed-SSL-Certificate-for-Nginx/"/>
    <id>https://amito.me/2018/Generating-A-Self-Signed-SSL-Certificate-for-Nginx/</id>
    <published>2018-12-27T15:09:52.000Z</published>
    <updated>2020-04-13T03:20:25.720Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>SSL 及其继任者 TLS 能够加密客户端与服务端的网络连接，保证网络传输信息的安全及完整性，不被他人窃取。有时我们会想要在本机测试加密网络连接，SSL 加密需要有一个 SSL 证书，我们可以为本机生成一个证书来测试。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="自签名的 -SSL- 证书"> 自签名的 SSL 证书 </h2><p> 使用 OpenSSL 创建一个自签名的单域名和泛著名的 SSL 证书很容易，一行命令主就可以。假设我们为本地的多个项目添加了多个 <code>.local</code> 结尾的域名。</p><pre class=" language-language-bash"><code class="language-language-bash">$ openssl req -x509 -nodes -days 1024 -newkey rsa:4096 -keyout local.key -out local.crt</code></pre><p> 运行后的结果如下：</p><pre class=" language-language-bash"><code class="language-language-bash">$ openssl req -x509 -nodes -days 1024 -newkey rsa:4096 -keyout local.key -out local.crtGenerating a 4096 bit RSA private key..........................................++..............++writing new private key to 'local.key'-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [XX]:CNState or Province Name (full name) []:BeijingLocality Name (eg, city) [Default City]:BeijingOrganization Name (eg, company) [Default Company Ltd]:localOrganizational Unit Name (eg, section) []:localCommon Name (eg, your name or your server's hostname) []:local,*.localEmail Address []:me@amito.me</code></pre><p> 各选项含义比较明显，比较重要的是 <code>Common Name</code>， 这是与要用 SSL 加密的域名或服务器 IP 相关的。如果是单域名， 就填 <code>local</code>；要是有多个项目，就填 <code>local,*.local</code>。<br>知道创建的过程后，就可以一行命令自动生成了。</p><pre class=" language-language-bash"><code class="language-language-bash">$ echo -e "CN\nBJ\n\Beijing\nlocal\nlocal\nlocal,\*.local\nme@amito.me"|openssl req -x509 -nodes -days 1024 -newkey rsa:4096 -keyout local.key -out local.crt</code></pre><p> 这样我们就在当前目录生成了一个 ssl 证书 <code>local.crt</code> 和对应的密钥 <code>local.key</code>。</p><h2 id="创建 -RootCA- 及自签名证书"> 创建 RootCA 及自签名证书 </h2><h3 id="生成 -Root-SSL- 证书"> 生成 Root SSL 证书 </h3><ol><li> 生成 Root Key</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ openssl genrsa -des3 -out RootCA.key 4096</code></pre><ol start="2"><li> 生成 RootCA 证书 </li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.pem</code></pre><h3 id="信任 -Root-SSL- 证书"> 信任 Root SSL 证书 </h3><h3 id="生成 - 网站 -SSL- 证书"> 生成 网站 SSL 证书 </h3><h2 id="配置 -Nginx- 使用 -SSL"> 配置 Nginx 使用 SSL</h2><h2 id="参考"> 参考 </h2><ol><li><a href="https://cloud.tencent.com/developer/article/1160294" target="_blank" rel="noopener"> 如何为 Nginx 创建自签名 SSL 证书 </a></li><li><a href="https://www.cnblogs.com/loleina/p/8418111.html" target="_blank" rel="noopener">https 学习笔记三 ----OpenSSL 生成 root CA 及签发证书 </a></li><li><a href="https://medium.freecodecamp.org/how-to-get-https-working-on-your-local-development-environment-in-5-minutes-7af615770eec" target="_blank" rel="noopener">How to get HTTPS working on your local development environment in 5 minutes</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSL 及其继任者 TLS 能够加密客户端与服务端的网络连接，保证网络传输信息的安全及完整性，不被他人窃取。有时我们会想要在本机测试加密网络连接，SSL 加密需要有一个 SSL 证书，我们可以为本机生成一个证书来测试。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://amito.me/categories/Linux/"/>
    
    
      <category term="SSL" scheme="https://amito.me/tags/SSL/"/>
    
      <category term="Nginx" scheme="https://amito.me/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>LVM 调整分区大小</title>
    <link href="https://amito.me/2018/LVM-Resize-Partitions/"/>
    <id>https://amito.me/2018/LVM-Resize-Partitions/</id>
    <published>2018-12-25T12:09:56.000Z</published>
    <updated>2020-04-13T03:20:25.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近在三台服务器上安装了系统，安装的时候选择的是自动分区，创建了一个 LVM 卷组， 结果大部分空间都分给了 HOME ， root 很小。 现在要求要将大部分空间重新分给 ROOT。 常用的文件系统如 ext4，xfs 都能很方便地在线调整大小的。 这里就简单记录一下如何调整分区大小的。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h3 id="制作一个 -Linux-LiveCD- 启动盘">制作一个 Linux LiveCD 启动盘</h3><p>对系统的 root 分区和 home 分区进行调整大小，可以直接线上调整大小。但是文件系统是 XFS 格式的，不好在线减少空间，就选取了这一个比较稳妥的方法 - 离线调整大小。</p><p>下载一个 LiveCD 镜像，然后刻录到 U 盘上， 或者通过 grub2 引导镜像启动。</p><h3 id="减小 -HOME- 分区大小">减小 HOME 分区大小</h3><ol><li>系统自动分区时创建了一个 LVM 卷组 <code>/dev/centos</code>， 分为 <code>swap</code>、<code>home</code>、<code>root</code> 三个卷。 在 Live 系统中，挂载 home 和 root 卷到：</li></ol><pre><code>$ sudo mkdir -p /mnt/{home,root}$ sudo mount /dev/centos/root /mnt/root$ sudo mount /dev/centos/home /mnt/home</code></pre><ol start="2"><li>默认分区格式为 XFS，无法减小大小。需要减小后重新格式化。减小之前做好数据备份。 还好 <code>home</code> 卷内容很少。-_-…</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo xfsdump -f /mnt/root/home/home.dump /mnt/home$ sudo umount /mnt/home</code></pre><ol start="3"><li>减小 home 卷大小</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo lvreduce -L 25G /dev/centos/home$ sudo mkfs.xfs -f /dev/centos/home</code></pre><ol start="4"><li>恢复 home 数据</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo mount /dev/centos/home /mnt/home$ sudo xfsrestore -f /mnt/root/home/home.dump /mnt/home$ sudo rm -f /mnt/root/home/home.dump</code></pre><ol start="5"><li>若是 <code>ext4</code> 分区，则要简单的多。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo lvreduce -L 25G /dev/centos/home$ sudo resize2fs /dev/centos/home### or simply and safely$ sudo lvresize --resize --size 25G /dev/centos/home</code></pre><h3 id="增大 -ROOT- 分区大小">增大 ROOT 分区大小</h3><p>扩大 root 分区就比较简单了。</p><ol><li>LVM 调整大小。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo lvextend -l +100%FREE /dev/centos/root</code></pre><ol start="2"><li><code>xfs</code> 分区确认大小调整</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo xfs_growfs /dev/centos/root</code></pre><ol start="3"><li><code>ext4</code> 分区确认大小调整</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo resize2fs /dev/centos/root</code></pre><ol start="4"><li>确认调整后的分区大小</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo lsblkNAME                                   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTsda                                      8:0    0   931G  0 disk├─sda1                                   8:1    0   200M  0 part /boot/efi├─sda2                                   8:2    0     1G  0 part /boot└─sda3                                   8:3    0 929.8G  0 part  ├─centos-root                        253:0    0 900.8G  0 lvm  /  ├─centos-swap                        253:1    0     4G  0 lvm  [SWAP]  └─centos-home                        253:2    0    25G  0 lvm  /home</code></pre><h3 id="重启系统">重启系统</h3><p>调整好之后，就可以重启系统了。</p><h3 id="在线调整大小">在线调整大小</h3><p>一般分区只能在线扩容，不能减少。鉴于 home 分区没有使用，可以不用重启系统到 Live 系统。 确保没有程序在使用 home 分区后， 备份 home 分区，然后可以按照上面的步骤进行调整大小了。 不过在线调整大小有风险，最好提前做好数据备份。</p><p>在 <a href="https://unix.stackexchange.com/questions/226872/how-to-shrink-root-filesystem-without-booting-a-livecd/227318#227318" target="_blank" rel="noopener"> 这篇</a> 回答中，提到了一种不重启减小 root 分区的方法，不过，如无必要，建议使用 Live 系统减小 root 分区容量。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在三台服务器上安装了系统，安装的时候选择的是自动分区，创建了一个 LVM 卷组， 结果大部分空间都分给了 HOME ， root 很小。 现在要求要将大部分空间重新分给 ROOT。 常用的文件系统如 ext4，xfs 都能很方便地在线调整大小的。 这里就简单记录一下如何调整分区大小的。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://amito.me/categories/Linux/"/>
    
    
      <category term="LVM" scheme="https://amito.me/tags/LVM/"/>
    
      <category term="XFS" scheme="https://amito.me/tags/XFS/"/>
    
      <category term="ext4" scheme="https://amito.me/tags/ext4/"/>
    
  </entry>
  
  <entry>
    <title>Ceph 运行中的故障分析与修复</title>
    <link href="https://amito.me/2018/Ceph-Troubleshooting/"/>
    <id>https://amito.me/2018/Ceph-Troubleshooting/</id>
    <published>2018-12-25T10:20:38.000Z</published>
    <updated>2020-04-13T03:20:25.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p> 在运行管理 Ceph 集群时，会遇到各种问题。这里记录了一些问题的分析与修复过程。</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><h2 id="Ceph">Ceph</h2><h3 id="HEALTH-WARN-clock-skew-detected">HEALTH_WARN clock skew detected</h3><p> 这种问题一般有两个原因： 一是 mon 节点上 ntpd 服务没有启用； 二是 Ceph 设置的时间偏差阈值过小。</p><ol><li> 如果是 CentOS 7， 确定 systemd-timesyncd 没有启动。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo ystemctl status systemd-timesyncd### disable it if enabled$ sudo systemctl disable --now systemd-timesyncd</code></pre><ol start="2"><li> 检查 <code>nptd</code> 服务有没有启用，没有启用或安装就安装并启用。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ sudo yum install -y ntpd ntpdate$ sudo systemctl enable --now ntpd.service$ sudo systemctl status ntpd.service</code></pre><ol start="3"><li> 有必要的话，修改 <code>/etc/ntp.conf</code>, 然后重启 <code>ntpd</code> 服务。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">server your-ntp-server1server your-ntp-server2</code></pre><ol start="4"><li> 重启 相关的 Ceph 服务。</li><li> 如果仍有这样的问题，可考虑适当增大 Ceph 的时间偏差阈值。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">### /etc/ceph/ceph.confmon clock drift allowed = 2mon clock drift warn backoff = 30</code></pre><ol start="6"><li> 将修改后的 <code>/etc/ceph/ceph</code> 推送给所有节点。</li></ol><pre class=" language-language-bash"><code class="language-language-bash">$ for  i in {mon list}; do    scp /etc/ceph/ceph.conf $i:/etc/ceph/    ssh $i sudo systemctl restart ceph-mon@$i.servicedone</code></pre><h2 id="Openstack">Openstack</h2><ol><li>P: 连不上集群.<br>S: 检查 <code>/etc/ceph/ceph.conf</code> 权限, 设置 <code>ceph</code> 或 <code>cinder</code> 可访问.</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在运行管理 Ceph 集群时，会遇到各种问题。这里记录了一些问题的分析与修复过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Ceph" scheme="https://amito.me/categories/Ceph/"/>
    
    
      <category term="Ceph" scheme="https://amito.me/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>通过网络远程安装 CentOS 7</title>
    <link href="https://amito.me/2018/Install-CentOS-7-Remotely-through-Internet/"/>
    <id>https://amito.me/2018/Install-CentOS-7-Remotely-through-Internet/</id>
    <published>2018-12-07T14:37:17.000Z</published>
    <updated>2020-04-13T03:20:25.721Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>最近工作中需要将几台服务器重装系统, 将 CentOS 6 换成最新的 CentOS 7.5. 于是研究了一下怎么从 grub lagecy 和 grub2 通过网络来升级或安装 CentOS 7.</p><a id="more"></a><hr width="100%" color="#C0C0C0" size="2"><!-- toc --><p>从 grub 通过网络安装很容易, 还可以设置 VNC 远程安装. 从 CentOS 6 安装 CentOS 7, 和对 CentOS 7 重装比较类似.</p><h2 id="从 -CentOS-6- 安装 -CentOS-7">从 CentOS 6 安装 CentOS 7</h2><p>在启动之前, 我们需要下载 <a href="http://mirrors.ustc.edu.cn/centos/7/os/x86_64/isolinux/vmlinuz" target="_blank" rel="noopener">vmlinuz</a> 和 <a href="http://mirrors.ustc.edu.cn/centos/7/os/x86_64/isoinux/initrd.img" target="_blank" rel="noopener">initrd.img</a> 到 <code>/boot/netinstall</code> 文件夹下, 如果哦已经无法进入系统, 可以放在一个可以访问的 U 盘上.</p><p>CentOS 6 的启动方式是 grub lagecy, 配置文件是 <code>/boot/grub/grub.conf</code>, 我们需要在启动项开始或结束加入一个新的启动项. 如果已经无法进入系统, 在 grub 没有毁坏的情况下, 在启动选择界面 按 c 进入手动输入模式, 输入以下启动命令.</p><pre class=" language-language-bash"><code class="language-language-bash">title CentOS 7 Installroot (hd0,2)kernel /netinstall/vmlinuz ro ip=192.168.1.10 netmask=255.255.255.254 gateway=192.168.1.1 dns=1.1.1.1 method=http://mirrors.ustc.edu.cn/centos/7/os/x86_64 lang=en_US keymap=us ksdevice=eth0initrd /netinstall/initrd.img</code></pre><p>其中, <code>ip</code>, <code>netmask</code>, <code>gateway</code>, <code>dns</code> 是网络连接信息, <code>method</code> 是网络安装包位置. 根据需要修改网络信息和安装位置. 根据 <code>/boot</code> 所在位置和所下载文件位置, 修改相应路径. 如果要利用 <strong>vnc</strong> 通过远程拖动进行安装, 需要在 <code>kernel</code> 语句后面加上 <code>vnc vncpassword=MyPassword</code> 就可以了. 另外, 如果默认网卡<strong> 不是</strong> <code>eth0</code>, 比如<code>eno1</code> 的话, 需要在 <code>kernel</code> 命令行加上 <code>ksdevice=eno1</code></p><p>如果一切没有问题, 之后便会进入图形化安装界面. 如果想自动进行安装, 你可以指定 <code>Kickstart</code> 安装文件. 并在 <code>kernel</code> 语句后面加上文件位置如 <code>ks=http://localfile/centos7.ks</code>, 这样就会自动进行安装了, 当然需要实现准备好 <code>ks</code> 文件.</p><h2 id="从 -CentOS-7- 重装 -CentOS-7">从 CentOS 7 重装 CentOS 7</h2><p>重装 CentOS 7 的过程与 从 CentOS 6 安装 CentOS 7 类似. CentOS 7 使用的引导器是 <code>grub2</code>, 启动项参数相应有些改变.</p><pre class=" language-language-bash"><code class="language-language-bash">menuentry "CentOS-7-Install"{set root=(hd0,msdos2)kernel16 /netinstall/vmlinuz ro ip=192.168.1.10::192.168.1.1:255.255.255.254:my_hostname:eth0:none nameserver=1.1.1.1 inst.repo=http://mirrors.ustc.edu.cn/centos/7/os/x86_64/ inst.vnc inst.vncpassword=MyPassword ksdevice=eth0 ks="http://where.my.ks.file.is" inst.lang=en_US inst.keymap=usinitrd16 /netinstall/initrd.img}</code></pre><p>其中 <code>ip</code> 的格式为 <code>ip::gateway:netmask:hostname:interface:none</code>, 或者 <code>ip=dhcp</code>. 如果 硬盘是 <code>GPT</code> 格式的, 则需要将 <code>(hd0,msdos2)</code> 改成 <code>(hd0,gpt2)</code>, 且要加上 <code>inst.gpt</code> 选项. 同样<br>的，需要注意网卡名 <strong>interface</strong> 和 ksdevice 一定要正确。 之后重启进入 CentOS 7 安装：</p><pre class=" language-language-bash"><code class="language-language-bash">grub2-reboot CentOS-7-Install</code></pre><p>这样重启后一般就会进入自动化安装 <code>CentOS 7</code> 的程序啦.</p><h2 id="Kickstart- 配置文件">Kickstart 配置文件</h2><p>一般安装好 <code>CentOS</code> 或 <code>Fedora</code> 后, 会在 <code>/root</code> 下有一个 <code>anaconda-ks.cfg</code>, 这就是一个 <code>Kickstart</code> 配置文件, 可以参考这个修改成适合自己的安装脚本。RHEL/CentOS 有一个图形化的配置工具 <strong>system-config-kickstart</strong> 可以简化 Kickstart 文件的生成配置。</p><p>下面是一个简单的 ks 配置文件。</p><pre class=" language-language-bash"><code class="language-language-bash">#version=DEVEL# System authorization informationauth --enableshadow --passalgo=sha512# Use network installationurl --url="http://mirror.ihep.ac.cn/centos/7/os/x86_64"# Use graphical installgraphical# Run the Setup Agent on first bootfirstboot --enableignoredisk --only-use=sda# Keyboard layouts# old format: keyboard us# new format:keyboard --vckeymap=us --xlayouts='us'# System languagelang en_US.UTF-8# Network informationnetwork  --bootproto=static --device=eno1 --gateway=202.122.33.1 --ip=202.122.33.38 --nameserver=202.122.33.44 --netmask=255.255.255.128 --ipv6=auto --activatenetwork  --bootproto=dhcp --device=eno2 --onboot=off --ipv6=autonetwork  --bootproto=dhcp --device=eno3 --onboot=off --ipv6=autonetwork  --bootproto=dhcp --device=eno4 --onboot=off --ipv6=autonetwork  --hostname=localhost.localdomain# Root passwordrootpw --iscrypted $6$7Xg630Hqe96PUCMu$mUzleXYhsnNBxHl.U1AZTGGVSqJ6U/7n2.psJ8nlXg0.MMFcEjngSAytOZhD8yM52d2s3PF7vpojhiF6s0iT2/# System servicesservices --enabled="chronyd"# System timezonetimezone Asia/Harbin --isUtcuser --groups=wheel --name=eos --password=$6$VWhRMFl9A7LKcekg$0zZOGfO2ezcfbGPRLbNVsrzylddEmlsFw5WTkZSa/0Oh5IGxVXvljRAn8O/sSFxdtHKiqioSYXXZpJ/ipqOaA/ --iscrypted --uid=1000 --gecos="eos" --gid=1000# System bootloader configurationbootloader --append=" crashkernel=auto" --location=mbr --boot-drive=sda# Partition clearing informationclearpart --all --initlabel --drives=sda# Disk partitioning informationpart /data --fstype="ext4" --ondisk=sda --size=123775 --label=datapart swap --fstype="swap" --ondisk=sda --size=8191part / --fstype="ext4" --ondisk=sda --size=51200 --label=rootpart /var --fstype="ext4" --ondisk=sda --size=102400 --label=varpart /boot --fstype="ext4" --ondisk=sda --size=500 --label=boot%packages@^developer-workstation-environment@base@core@debugging@desktop-debugging@development@dial-up@directory-client@file-server@fonts@gnome-apps@gnome-desktop@guest-desktop-agents@hardware-monitoring@input-methods@internet-applications@internet-browser@java-platform@load-balancer@mariadb@multimedia@network-file-system-client@performance@perl-runtime@print-client@python-web@ruby-runtime@system-admin-tools@virtualization-client@virtualization-hypervisor@virtualization-tools@web-server@x11chronykexec-tools%end%addon com_redhat_kdump --enable --reserve-mb='auto'%end%anacondapwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notemptypwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyokpwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty%end</code></pre><p>需要特别注意的是，安装位置选择硬盘一定要慎重，一定要确定好所选 <strong> 硬盘 </strong> 和<strong>分区 </strong> 方案后，才能进行安装，否则容易造成数据丢失。</p><hr><h2 id="参考">参考</h2><ol><li><a href="http://www.danpros.com/2016/02/how-to-install-centos-7-remotely-using-vnc" target="_blank" rel="noopener">How to install CentOS 7 remotely using VNC</a></li><li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/ap-admin-options" target="_blank" rel="noopener">Redhat Enterprise Linux 6 - Installation Guide - BOOT OPTIONS</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近工作中需要将几台服务器重装系统, 将 CentOS 6 换成最新的 CentOS 7.5. 于是研究了一下怎么从 grub lagecy 和 grub2 通过网络来升级或安装 CentOS 7.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://amito.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://amito.me/tags/Linux/"/>
    
      <category term="CentOS" scheme="https://amito.me/tags/CentOS/"/>
    
  </entry>
  
</feed>
